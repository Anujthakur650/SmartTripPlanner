import Foundation
import SwiftData

@MainActor
final class TripDataController: ObservableObject {
    static let cloudIdentifier = "iCloud.com.smarttripplanner.SmartTripPlanner"

    let container: ModelContainer
    let context: ModelContext
    let syncCoordinator: TripSyncCoordinator

    let userProfiles: SwiftDataRepository<UserProfileRecord>
    let trips: SwiftDataRepository<TripRecord>
    let segments: SwiftDataRepository<SegmentRecord>
    let dayPlanItems: SwiftDataRepository<DayPlanItemRecord>
    let places: SwiftDataRepository<PlaceRecord>
    let routes: SwiftDataRepository<RouteRecord>
    let packingItems: SwiftDataRepository<PackingItemRecord>
    let documents: SwiftDataRepository<DocumentAssetRecord>
    let collaborators: SwiftDataRepository<CollaboratorRecord>
    let activityLogs: SwiftDataRepository<ActivityLogRecord>

    init(inMemory: Bool = false, cloudAdapter: CloudKitSyncAdapter? = nil) {
        let configuration = ModelConfiguration(
            for: TripDataSchemaV1.models,
            configurationName: "default",
            isStoredInMemoryOnly: inMemory,
            cloudKitContainerIdentifier: inMemory ? nil : Self.cloudIdentifier,
            cloudKitDatabase: inMemory ? .automatic : .private
        )
        do {
            container = try ModelContainer(
                for: TripDataSchema.self,
                migrationPlan: TripDataMigrationPlan.self,
                configurations: [configuration]
            )
        } catch {
            fatalError("Failed to bootstrap SwiftData container: \(error)")
        }
        context = ModelContext(container)
        context.undoManager = nil
        context.mergePolicy = .mergeByPropertyObjectTrump

        let adapter = cloudAdapter ?? NoopCloudKitSyncAdapter()
        syncCoordinator = TripSyncCoordinator(container: container, context: context, cloudAdapter: adapter)

        userProfiles = SwiftDataRepository(context: context, syncCoordinator: syncCoordinator, entityName: String(describing: UserProfileRecord.self))
        trips = SwiftDataRepository(context: context, syncCoordinator: syncCoordinator, entityName: String(describing: TripRecord.self))
        segments = SwiftDataRepository(context: context, syncCoordinator: syncCoordinator, entityName: String(describing: SegmentRecord.self))
        dayPlanItems = SwiftDataRepository(context: context, syncCoordinator: syncCoordinator, entityName: String(describing: DayPlanItemRecord.self))
        places = SwiftDataRepository(context: context, syncCoordinator: syncCoordinator, entityName: String(describing: PlaceRecord.self))
        routes = SwiftDataRepository(context: context, syncCoordinator: syncCoordinator, entityName: String(describing: RouteRecord.self))
        packingItems = SwiftDataRepository(context: context, syncCoordinator: syncCoordinator, entityName: String(describing: PackingItemRecord.self))
        documents = SwiftDataRepository(context: context, syncCoordinator: syncCoordinator, entityName: String(describing: DocumentAssetRecord.self))
        collaborators = SwiftDataRepository(context: context, syncCoordinator: syncCoordinator, entityName: String(describing: CollaboratorRecord.self))
        activityLogs = SwiftDataRepository(context: context, syncCoordinator: syncCoordinator, entityName: String(describing: ActivityLogRecord.self))

        registerDefaultMergeHandlers()
    }

    func makePreviewSeed() async {
        guard (try? userProfiles.all(includeDeleted: false).isEmpty) ?? true else { return }
        let profile = UserProfileRecord(displayName: "Preview User", email: "preview@example.com")
        try? await userProfiles.insert(profile)
        let trip = TripRecord(
            name: "Sample Adventure",
            summary: "An autogenerated QA sample",
            startDate: Date().addingTimeInterval(86400),
            endDate: Date().addingTimeInterval(86400 * 7),
            owner: profile
        )
        try? await trips.insert(trip)
        let destination = PlaceRecord(
            name: "Sample Destination",
            subtitle: "Preview City Center",
            latitude: 37.7749,
            longitude: -122.4194,
            trip: trip
        )
        try? await places.insert(destination)
        let segment = SegmentRecord(
            name: "Flight",
            transport: .flight,
            notes: "Preview itinerary",
            departureDate: Date().addingTimeInterval(86400),
            arrivalDate: Date().addingTimeInterval(86400 * 2),
            trip: trip,
            destination: destination
        )
        try? await segments.insert(segment)
        let planItem = DayPlanItemRecord(
            title: "Welcome Dinner",
            scheduledDate: Date().addingTimeInterval(86400),
            order: 0,
            trip: trip,
            place: destination
        )
        try? await dayPlanItems.insert(planItem)
    }

    private func registerDefaultMergeHandlers() {
        registerHandler(for: UserProfileRecord.self)
        registerHandler(for: TripRecord.self)
        registerHandler(for: SegmentRecord.self)
        registerHandler(for: DayPlanItemRecord.self)
        registerHandler(for: PlaceRecord.self)
        registerHandler(for: RouteRecord.self)
        registerHandler(for: PackingItemRecord.self)
        registerHandler(for: DocumentAssetRecord.self)
        registerHandler(for: CollaboratorRecord.self)
        registerHandler(for: ActivityLogRecord.self)
    }

    private func registerHandler<Entity>(for type: Entity.Type) where Entity: PersistentModel & SoftDeletableEntity & TimestampedEntity {
        let entityName = String(describing: type)
        syncCoordinator.registerUpdateHandler(for: entityName) { [weak syncCoordinator] payload, context in
            let data = payload.payload
            guard let envelope = try? JSONDecoder().decode(TripSyncCoordinator.ChangeEnvelope.self, from: data),
                  let syncCoordinator else { return }
            let id = UUID(uuidString: payload.recordIdentifier) ?? envelope.id
            guard let entity = try context.fetch(
                FetchDescriptor<Entity>(predicate: #Predicate { $0.id == id })
            ).first else {
                return
            }
            guard syncCoordinator.shouldAcceptRemoteChange(localUpdatedAt: entity.updatedAt, remoteUpdatedAt: envelope.updatedAt) else { return }
            entity.updatedAt = envelope.updatedAt
            if envelope.isDeleted {
                entity.isDeleted = true
                entity.deletedAt = envelope.updatedAt
            }
            if let cloudAware = entity as? CloudIdentifiableEntity {
                cloudAware.cloudIdentifier = payload.recordIdentifier
                cloudAware.lastSyncedAt = Date()
            }
        }
        syncCoordinator.registerDeletionHandler(for: entityName) { [weak syncCoordinator] deletion, context in
            guard let syncCoordinator,
                  let id = UUID(uuidString: deletion.recordIdentifier) else { return }
            guard let entity = try context.fetch(
                FetchDescriptor<Entity>(predicate: #Predicate { $0.id == id })
            ).first else {
                return
            }
            guard syncCoordinator.shouldAcceptRemoteChange(localUpdatedAt: entity.updatedAt, remoteUpdatedAt: deletion.deletedAt) else { return }
            entity.isDeleted = true
            entity.deletedAt = deletion.deletedAt
            entity.updatedAt = deletion.deletedAt
            if let cloudAware = entity as? CloudIdentifiableEntity {
                cloudAware.cloudIdentifier = deletion.recordIdentifier
                cloudAware.lastSyncedAt = Date()
            }
        }
    }
}
